// @ts-nocheck - Deno environment, types resolved at runtime
/**
 * Supabase Edge Function: sync-cj-products
 * Synchronizes products from CJ Dropshipping to Supabase
 *
 * Usage:
 *   POST /sync-cj-products
 *   Body: { keyWord?: string, categoryId?: string, page?: number, pageSize?: number }
 */

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { getProductList, getProductDetails } from '../_shared/cj-api/index';

// Helper to generate UUID v4 using crypto.randomUUID() if available, otherwise fallback
function generateUUID(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for environments without crypto.randomUUID
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface SyncRequest {
  keyWord?: string;
  categoryId?: string;
  page?: number;
  pageSize?: number;
  maxPages?: number; // Limit how many pages to sync
}

interface SyncStats {
  processed: number;
  created: number;
  updated: number;
  failed: number;
  errors: string[];
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Parse request
    const body: SyncRequest = await req.json();
    const {
      keyWord = 'K-Beauty', // Default search for K-Beauty products
      categoryId,
      page = 1,
      pageSize = 20,
      maxPages = 5, // Limit to 5 pages by default
    } = body;

    console.log('Starting CJ product sync:', { keyWord, categoryId, page, pageSize, maxPages });

    // Create sync log
    const { data: syncLog } = await supabase
      .from('cj_sync_logs')
      .insert({
        sync_type: 'products',
        status: 'started',
        metadata: { keyWord, categoryId, page, pageSize, maxPages },
      })
      .select()
      .single();

    const syncId = syncLog?.id;
    const startTime = Date.now();
    const stats: SyncStats = {
      processed: 0,
      created: 0,
      updated: 0,
      failed: 0,
      errors: [],
    };

    try {
      // Fetch products from CJ API (with pagination)
      let currentPage = page;
      let hasMorePages = true;

      while (hasMorePages && currentPage <= page + maxPages - 1) {
        console.log(`Fetching page ${currentPage}...`);

        const productData = await getProductList({
          keyWord,
          categoryId,
          page: currentPage,
          pageSize,
        });

        const { list: products, total } = productData || { list: [], total: 0 };

        // Safety check: ensure products is an array
        if (!products || !Array.isArray(products)) {
          console.error('Invalid product list:', productData);
          throw new Error('Invalid API response: products list is not an array');
        }

        console.log(`Found ${products.length} products (total: ${total || 0})`);

        // Process each product
        for (const cjProduct of products) {
          stats.processed++;

          try {
            // Map CJ product to our schema
            // Note: Only include fields that exist in the Supabase table
            // Don't include 'id' - it will be auto-generated by the database
            const productData: Record<string, any> = {
              cj_product_id: cjProduct.pid || cjProduct.id,
              name: cjProduct.productNameEn || '',
              description: cjProduct.productDescEn || '',
              price: cjProduct.sellPrice || 0,
              stock: cjProduct.warehouseInventoryNum || 0,
              images: cjProduct.productImageList || (cjProduct.productImage ? [cjProduct.productImage] : []),
              variants: cjProduct.variants || [],
              category_id: cjProduct.categoryId || '',
              sku: cjProduct.productSku || '',
              updated_at: new Date().toISOString(),
            };
            
            // Only add category if it's not empty (to avoid schema errors)
            if (cjProduct.categoryName) {
              productData.category = cjProduct.categoryName;
            }

            // Check if product already exists
            const { data: existing } = await supabase
              .from('products')
              .select('id, created_at')
              .eq('cj_product_id', productData.cj_product_id)
              .single();

            let isNew = false;

            if (existing) {
              // Update existing product
              const { error } = await supabase
                .from('products')
                .update(productData)
                .eq('cj_product_id', productData.cj_product_id);

              if (error) {
                throw error;
              }

              // Check if it was just created (within 2 seconds)
              const createdTime = new Date(existing.created_at).getTime();
              isNew = createdTime > startTime - 2000;
            } else {
              // Insert new product - generate UUID manually to ensure it works
              const { error } = await supabase
                .from('products')
                .insert({
                  id: generateUUID(),
                  ...productData,
                });

              if (error) {
                throw error;
              }

              isNew = true;
            }

            if (isNew) {
              stats.created++;
            } else {
              stats.updated++;
            }

            console.log(`âœ“ Synced product: ${cjProduct.productNameEn} (${cjProduct.pid})`);
          } catch (error) {
            stats.failed++;
            const errorMsg = `Failed to sync product ${cjProduct.pid}: ${error.message}`;
            console.error(errorMsg);
            stats.errors.push(errorMsg);
          }
        }

        // Check if there are more pages
        const totalPages = Math.ceil(total / pageSize);
        hasMorePages = currentPage < totalPages && currentPage < page + maxPages - 1;
        currentPage++;
      }

      // Update sync log with success
      const duration = Date.now() - startTime;
      await supabase
        .from('cj_sync_logs')
        .update({
          status: stats.failed > 0 ? 'partial' : 'success',
          items_processed: stats.processed,
          items_created: stats.created,
          items_updated: stats.updated,
          items_failed: stats.failed,
          error_message: stats.errors.length > 0 ? stats.errors.join('; ') : null,
          completed_at: new Date().toISOString(),
          duration_ms: duration,
        })
        .eq('id', syncId);

      console.log('Sync completed:', stats);

      return new Response(
        JSON.stringify({
          success: true,
          message: 'Product sync completed',
          stats,
          syncId,
          duration: `${duration}ms`,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 200,
        }
      );
    } catch (error) {
      // Update sync log with failure
      await supabase
        .from('cj_sync_logs')
        .update({
          status: 'failed',
          error_message: error.message,
          completed_at: new Date().toISOString(),
          duration_ms: Date.now() - startTime,
        })
        .eq('id', syncId);

      throw error;
    }
  } catch (error) {
    console.error('Error syncing products:', error);

    return new Response(
      JSON.stringify({
        success: false,
        error: error.message,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
